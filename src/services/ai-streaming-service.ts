import OpenAI from 'openai';
import { getMaskConfig, normalizeMaskType } from '../shared/mask-types';
import { getCoreSystemPrompt } from './ai-prompt-shared';
import { AIColorAdjustments } from './types';


export interface StreamingUpdate {
    type: 'thinking' | 'analysis' | 'tool_call' | 'progress' | 'complete' | 'step_progress' | 'step_transition';
    content: string;
    step?: string;
    progress?: number;
    toolName?: string;
    toolArgs?: any;
}

export interface StreamingOptions {
    onUpdate?: (update: StreamingUpdate) => void;
    aiFunctions?: {
        masks?: boolean;
        colorGrading?: boolean;
        hsl?: boolean;
        curves?: boolean;
        grain?: boolean;
        pointColor?: boolean;
    };
}

export class AIStreamingService {
    private openai: OpenAI;

    constructor(apiKey: string, _model: string = 'gpt-5') {
        this.openai = new OpenAI({
            apiKey: apiKey,
        });
    }

    async analyzeColorMatchWithStreaming(
        baseImageBase64?: string | string[],
        targetImageBase64?: string,
        hint?: string,
        options?: StreamingOptions & { styleOptions?: any }
    ): Promise<AIColorAdjustments> {
        const { onUpdate } = options || {};

        console.log('[AI STREAMING] Starting analysis with GPT-5 direct API:', {
            hasBaseImageBase64: !!baseImageBase64,
            hasTargetImageBase64: !!targetImageBase64,
            hasHint: !!hint
        });

        try {
            // Build messages for OpenAI
            const messages = await this.buildOpenAIMessages(baseImageBase64, targetImageBase64, hint, options);
            
            // Define tools for OpenAI
            const tools = this.buildOpenAITools(options);
            
            // Get system prompt
            const systemPrompt = this.getSystemPrompt(options || {});

            onUpdate?.({
                type: 'thinking',
                content: 'Analyzing images with GPT-5...',
                step: 'analysis',
                progress: 20
            });

                        // Call OpenAI directly with GPT-5
                        const response = await this.openai.chat.completions.create({
                            model: 'gpt-5',
                            messages: [
                                { role: 'system', content: systemPrompt },
                                ...messages
                            ],
                            tools: tools,
                            tool_choice: 'auto',
                            max_completion_tokens: 12000
                        });

            console.log('[AI STREAMING] GPT-5 response received:', {
                hasChoices: !!response.choices,
                choicesLength: response.choices?.length || 0,
                hasToolCalls: !!response.choices?.[0]?.message?.tool_calls
            });

            // Extract tool calls and results
            const toolCalls = response.choices[0]?.message?.tool_calls || [];
            console.log('[AI STREAMING] Tool calls found:', toolCalls.length);

            if (toolCalls.length === 0) {
                console.warn('[AI STREAMING] No tool calls made by GPT-5');
                onUpdate?.({
                    type: 'thinking',
                    content: 'Warning: No tools were used - this may result in incomplete results',
                    step: 'warning',
                    progress: 90
                });
            }

            // Process tool calls to extract adjustments
            const adjustments = await this.processToolCalls(toolCalls, onUpdate);
            
            onUpdate?.({
                type: 'thinking',
                content: 'GPT-5 analysis complete!',
                step: 'complete',
                progress: 100
            });

            return this.ensureAdjustmentMetadata(adjustments);
        } catch (error) {
            console.error('GPT-5 Direct API Error:', error);
            onUpdate?.({
                type: 'thinking',
                content: `Error during analysis: ${error instanceof Error ? error.message : 'Unknown error'}`,
                step: 'error',
                progress: 100
            });
            throw error;
        }
    }

    private async processToolCalls(toolCalls: any[], onUpdate?: (update: any) => void): Promise<AIColorAdjustments> {
        console.log('[AI STREAMING] Processing tool calls:', toolCalls.length);
        
        let adjustments: AIColorAdjustments = {
            preset_name: 'GPT-5 Generated',
            description: 'Generated by GPT-5 AI analysis',
            masks: []
        };

        for (const toolCall of toolCalls) {
            if (toolCall.type === 'function') {
                const functionName = toolCall.function.name;
                const functionArgs = JSON.parse(toolCall.function.arguments);
                
                console.log('[AI STREAMING] Processing tool call:', functionName);
                
                onUpdate?.({
                    type: 'tool_call',
                    content: `Processing ${functionName}...`,
                    step: 'tool_call',
                    progress: 50
                });

                switch (functionName) {
                    case 'analyze_color_palette':
                        // Store color analysis for reference
                        console.log('[AI STREAMING] Color palette analysis:', functionArgs);
                        break;
                        
                    case 'generate_global_adjustments':
                        // Merge global adjustments directly into the main object
                        Object.assign(adjustments, functionArgs);
                        console.log('[AI STREAMING] Global adjustments set:', functionArgs);
                        break;
                        
                    case 'generate_masks':
                        if (functionArgs.masks) {
                            adjustments.masks = functionArgs.masks;
                            console.log('[AI STREAMING] Masks set:', functionArgs.masks.length);
                        }
                        break;
                        
                    case 'name_and_describe':
                        if (functionArgs.preset_name) {
                            adjustments.preset_name = functionArgs.preset_name;
                        }
                        if (functionArgs.description) {
                            adjustments.description = functionArgs.description;
                        }
                        console.log('[AI STREAMING] Preset named:', functionArgs.preset_name);
                        break;
                }
            }
        }

        return adjustments;
    }

    private async buildOpenAIMessages(
        baseImageBase64?: string | string[],
        targetImageBase64?: string,
        hint?: string,
        _options?: StreamingOptions & { styleOptions?: any }
    ): Promise<any[]> {
        const messages: any[] = [];

        // Add reference images
        if (baseImageBase64) {
            const baseImages = Array.isArray(baseImageBase64) ? baseImageBase64 : [baseImageBase64];
            const imageContents = baseImages.map(image => ({
                type: 'image_url',
                image_url: {
                    url: `data:image/jpeg;base64,${image}`,
                    detail: 'high'
                }
            }));

            messages.push({
                role: 'user',
                content: [
                    {
                        type: 'text',
                        text: 'REFERENCE IMAGES: These images show the style you need to match. Analyze them and create adjustments that recreate this look.'
                    },
                    ...imageContents
                ]
            });
        }

        // Add target image
        if (targetImageBase64) {
            messages.push({
                role: 'user',
                content: [
                    {
                type: 'text',
                        text: 'TARGET IMAGE: This is the image to be modified to match the reference style.'
                    },
                    {
                        type: 'image_url',
                        image_url: {
                            url: `data:image/jpeg;base64,${targetImageBase64}`,
                detail: 'high'
                        }
                    }
                ]
            });
        } else if (baseImageBase64) {
            messages.push({
                role: 'user',
                content: [
                    {
                type: 'text',
                        text: 'NO TARGET IMAGE: Create a preset based on the reference image style that can be applied to any similar image.'
                    }
                ]
            });
        }

        // Add hint/prompt
        if (hint) {
            messages.push({
                role: 'user',
                content: `STYLE DESCRIPTION: ${hint}`
            });
        }

        return messages;
    }

    private buildOpenAITools(options?: StreamingOptions): any[] {
        const tools: any[] = [
            {
                type: 'function',
                function: {
                    name: 'analyze_color_palette',
                    description: 'MANDATORY: Analyze the color palette and dominant colors in the reference images. This is REQUIRED for all analysis.',
                    parameters: {
                        type: 'object',
                        properties: {
                            dominant_colors: {
                                type: 'array',
                                items: { type: 'string' },
                                description: 'Primary colors found in the reference images'
                            },
                            color_temperature: {
                                type: 'string',
                                enum: ['warm', 'cool', 'neutral'],
                                description: 'Overall color temperature'
                            },
                            color_saturation: {
                                type: 'string',
                                enum: ['muted', 'moderate', 'vibrant', 'oversaturated'],
                                description: 'Overall saturation level'
                            },
                            color_contrast: {
                                type: 'string',
                                enum: ['low', 'medium', 'high'],
                                description: 'Color contrast level'
                            },
                            color_relationships: {
                                type: 'string',
                                description: 'How colors relate to each other and create harmony'
                            },
                            style_notes: {
                                type: 'string',
                                description: 'Key observations about the color style'
                            }
                        },
                        required: ['dominant_colors', 'color_temperature', 'color_saturation', 'color_contrast', 'color_relationships', 'style_notes']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'generate_global_adjustments',
                    description: 'MANDATORY: Generate global Lightroom/Camera Raw adjustments for the entire image. This is REQUIRED for all analysis.',
                    parameters: {
                        type: 'object',
                        properties: {
                            exposure: { type: 'number', description: 'Exposure adjustment (-5 to +5)' },
                            contrast: { type: 'number', description: 'Contrast adjustment (-100 to +100)' },
                            highlights: { type: 'number', description: 'Highlights adjustment (-100 to +100)' },
                            shadows: { type: 'number', description: 'Shadows adjustment (-100 to +100)' },
                            whites: { type: 'number', description: 'Whites adjustment (-100 to +100)' },
                            blacks: { type: 'number', description: 'Blacks adjustment (-100 to +100)' },
                            vibrance: { type: 'number', description: 'Vibrance adjustment (-100 to +100)' },
                            saturation: { type: 'number', description: 'Saturation adjustment (-100 to +100)' },
                            temperature: { type: 'number', description: 'Temperature adjustment (-100 to +100)' },
                            tint: { type: 'number', description: 'Tint adjustment (-100 to +100)' },
                            camera_profile: { type: 'string', description: 'Camera profile name' }
                        },
                        required: ['exposure', 'contrast', 'highlights', 'shadows', 'whites', 'blacks', 'vibrance', 'saturation', 'temperature', 'tint', 'camera_profile']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'name_and_describe',
                    description: 'MANDATORY: Generate a preset name and description for the recipe. This is REQUIRED for all analysis.',
                    parameters: {
                        type: 'object',
                        properties: {
                            preset_name: {
                                type: 'string',
                                description: 'Short, friendly preset name in Title Case (2-4 words)'
                            },
                            description: {
                                type: 'string',
                                description: '1-2 sentence description of the recipe style and mood'
                            }
                        },
                        required: ['preset_name', 'description']
                    }
                }
            }
        ];

        // Add masks tool if enabled
        if (options?.aiFunctions?.masks !== false) {
            tools.push({
                type: 'function',
                function: {
                    name: 'generate_masks',
                    description: 'Generate local adjustment masks for targeted editing of specific areas. Use this to create precise local adjustments for faces, skies, subjects, or backgrounds.',
                    parameters: {
                        type: 'object',
                        properties: {
                            masks: {
                                type: 'array',
                                items: {
                                    type: 'object',
                                    properties: {
                                        type: { type: 'string', description: 'Mask type (face, sky, subject, background)' },
                                        name: { type: 'string', description: 'Mask name' },
                                        adjustments: {
                                            type: 'object',
                                            properties: {
                                                exposure: { type: 'number' },
                                                contrast: { type: 'number' },
                                                highlights: { type: 'number' },
                                                shadows: { type: 'number' },
                                                vibrance: { type: 'number' },
                                                saturation: { type: 'number' }
                                            }
                                        }
                                    }
                                },
                                maxItems: 3,
                                description: 'Array of masks to apply (max 3 masks)'
                            },
                            mask_strategy: {
                                type: 'string',
                                description: 'Strategy for mask placement and selection'
                            },
                            mask_notes: {
                                type: 'string',
                                description: 'Notes about why these masks were chosen'
                            }
                        },
                        required: ['masks', 'mask_strategy', 'mask_notes']
                    }
                }
            });
        }

        return tools;
    }


    private getDefaultAdjustments(): AIColorAdjustments {
        return {
            preset_name: 'Custom Recipe',
            description: 'A custom color grading recipe',
            camera_profile: 'Adobe Color',
            exposure: 0,
            contrast: 0,
            highlights: 0,
            shadows: 0,
            whites: 0,
            blacks: 0,
            vibrance: 0,
            saturation: 0
        };
    }



    private ensureAdjustmentMetadata(adjustments: AIColorAdjustments | null): AIColorAdjustments {
        const ensured = adjustments ? { ...adjustments } : { ...this.createDefaultAdjustments() };

        if (!ensured.description || ensured.description.trim().length === 0) {
            ensured.description = 'A professional color grading recipe with carefully balanced tones and contrast.';
        }

        if (!ensured.preset_name || ensured.preset_name.trim().length === 0) {
            ensured.preset_name = 'Custom Recipe';
        }

        const normalizedProfile = this.normalizeCameraProfileName(ensured.camera_profile) || this.autoSelectProfileFromResult(ensured);
        ensured.camera_profile = normalizedProfile;

        return ensured;
    }

    private getSystemPrompt(_options: StreamingOptions): string {
        const base = getCoreSystemPrompt({
            includeMaskTypes: true,
            includeTechniques: true,
            includeRequirements: true
        });
        return `${base}

CRITICAL REFERENCE IMAGE REQUIREMENTS:
- When reference images are provided, you MUST analyze them thoroughly
- Create adjustments that precisely match the reference style
- Use the analyze_color_palette tool to understand the color characteristics
- Use the generate_global_adjustments tool to create matching adjustments
- Use the name_and_describe tool to create an appropriate preset name

CRITICAL TOOL USAGE REQUIREMENTS:
- You MUST use the available tools to complete your task
- Always call the required tools to generate a complete preset
- Do not provide text-only responses - use the tools instead`;
    }



    private parseResultFromText(text: string): AIColorAdjustments | null {
        // Try to extract structured data from the text
        try {
            // Look for JSON-like structures in the text
            const jsonMatches = text.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g);
            if (jsonMatches) {
                for (const match of jsonMatches) {
                    try {
                        const parsed = JSON.parse(match);
                        // Check if it looks like a valid AIColorAdjustments object
                        if (parsed && typeof parsed === 'object' && (parsed.preset_name || parsed.confidence !== undefined)) {
                            return parsed as AIColorAdjustments;
                        }
                    } catch {
                        // Continue to next match
                        continue;
                    }
                }
            }
        } catch (error) {
            console.warn('Could not parse result from text:', error);
        }
        return null;
    }

    // Normalize any free-form profile name to Adobe's canonical set
    private normalizeCameraProfileName(name?: string): string | undefined {
        if (!name) return undefined;
        const n = String(name).toLowerCase();
        if (/mono|black\s*&?\s*white|b\s*&\s*w/.test(n)) return 'Adobe Monochrome';
        if (/portrait|people|skin/.test(n)) return 'Adobe Portrait';
        if (/landscape|sky|mountain|nature/.test(n)) return 'Adobe Landscape';
        if (/color|standard|default|auto/.test(n)) return 'Adobe Color';
        return 'Adobe Color';
    }

    // Pick an Adobe profile using the adjustments and mask hints
    private autoSelectProfileFromResult(adjustments: AIColorAdjustments): string {
        const isBW =
            !!adjustments.monochrome ||
            adjustments.treatment === 'black_and_white' ||
            (typeof adjustments.saturation === 'number' && adjustments.saturation <= -100);
        if (isBW) return 'Adobe Monochrome';

        const masks = (adjustments as any).masks || [];
        let faceCount = 0;
        let landscapeLike = 0;
        let hasSky = false;
        for (const m of masks) {
            let t: any = m?.type;
            if (typeof t === 'string') t = normalizeMaskType(t);
            const cfg = typeof t === 'string' ? getMaskConfig(t) : undefined;
            const cat = cfg?.category;
            if (cat === 'face' || t === 'subject' || t === 'person') faceCount++;
            if (cat === 'landscape' || cat === 'background') landscapeLike++;
            if (t === 'sky') hasSky = true;
        }
        if (faceCount > 0) return 'Adobe Portrait';
        if (hasSky || landscapeLike > 0) return 'Adobe Landscape';
        return 'Adobe Color';
    }

    private createDefaultAdjustments(): AIColorAdjustments {
        return {
            preset_name: 'Custom Recipe',
            description: 'A balanced color grading recipe with natural tones and clean contrast.',
            confidence: 0.5,
            camera_profile: 'Adobe Color',
            exposure: 0,
            contrast: 0,
            highlights: 0,
            shadows: 0,
            whites: 0,
            blacks: 0,
            vibrance: 0,
            saturation: 0
        };
    }


}
