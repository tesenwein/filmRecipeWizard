import OpenAI from 'openai';
import { getMaskConfig, normalizeMaskType } from '../shared/mask-types';
import { getCoreSystemPrompt } from './ai-prompt-shared';
import { AIColorAdjustments } from './types';


export interface AIOptions {
    aiFunctions?: {
        masks?: boolean;
        colorGrading?: boolean;
        hsl?: boolean;
        curves?: boolean;
        grain?: boolean;
        pointColor?: boolean;
    };
    styleOptions?: {
        includeMasks?: boolean;
        enableCurves?: boolean;
        enableColorGrading?: boolean;
        enableHSL?: boolean;
        enableGrain?: boolean;
        enableVignette?: boolean;
        enablePointColor?: boolean;
    };
}

export class AIService {
    private openai: OpenAI;

    constructor(apiKey: string, _model: string = 'gpt-5.2-2025-12-11') {
        this.openai = new OpenAI({
            apiKey: apiKey,
        });
    }

    async analyzeColorMatch(
        baseImageBase64?: string | string[],
        targetImageBase64?: string,
        hint?: string,
        options?: AIOptions
    ): Promise<AIColorAdjustments> {
        try {
            // Build messages for OpenAI
            const messages = await this.buildOpenAIMessages(baseImageBase64, undefined, hint, options);
            
            // Define tools for OpenAI
            const tools = this.buildOpenAITools(options);
            
            // Get system prompt
            const systemPrompt = this.getSystemPrompt(options || {});

            // Call OpenAI directly with GPT-5
            const response = await this.openai.chat.completions.create({
                model: 'gpt-5.2-2025-12-11',
                messages: [
                    { role: 'system', content: systemPrompt },
                    ...messages
                ],
                tools: tools,
                tool_choice: 'required',
                max_completion_tokens: 12000
            });

            // Extract tool calls and results
            const toolCalls = response.choices[0]?.message?.tool_calls || [];

            if (toolCalls.length === 0) {
                console.warn('[AI] No tool calls made by GPT-5');
            }

            // Process tool calls to extract adjustments
            const adjustments = await this.processToolCalls(toolCalls);

            return this.ensureAdjustmentMetadata(adjustments);
        } catch (error) {
            console.error('GPT-5 API Error:', error);
            throw error;
        }
    }

    private async processToolCalls(toolCalls: any[]): Promise<AIColorAdjustments> {
        
        let adjustments: AIColorAdjustments = {
            preset_name: 'GPT-5 Generated',
            description: 'Generated by GPT-5 AI analysis',
            masks: []
        };

        for (const toolCall of toolCalls) {
            if (toolCall.type === 'function') {
                const functionName = toolCall.function.name;
                const functionArgs = JSON.parse(toolCall.function.arguments);

                switch (functionName) {
                    case 'analyze_color_palette':
                        // Store color analysis for reference
                        break;
                        
                    case 'generate_global_adjustments':
                        // Merge global adjustments directly into the main object
                        Object.assign(adjustments, functionArgs);
                        break;
                        
                    case 'generate_masks':
                        if (functionArgs.masks) {
                            adjustments.masks = functionArgs.masks;
                        }
                        break;
                        
                    case 'name_and_describe':
                        if (functionArgs.preset_name) {
                            adjustments.preset_name = functionArgs.preset_name;
                        }
                        if (functionArgs.description) {
                            adjustments.description = functionArgs.description;
                        }
                        if (typeof functionArgs.confidence === 'number') {
                            adjustments.confidence = functionArgs.confidence;
                        }
                        break;
                }
            }
        }

        return adjustments;
    }

    private async buildOpenAIMessages(
        baseImageBase64?: string | string[],
        _targetImageBase64?: string,
        hint?: string,
        _options?: AIOptions
    ): Promise<any[]> {
        const messages: any[] = [];

        // Add reference images
        if (baseImageBase64) {
            const baseImages = Array.isArray(baseImageBase64) ? baseImageBase64 : [baseImageBase64];
            const imageContents = baseImages.map(image => ({
                type: 'image_url',
                image_url: {
                    url: `data:image/jpeg;base64,${image}`,
                    detail: 'high'
                }
            }));

            messages.push({
                role: 'user',
                content: [
                    {
                        type: 'text',
                        text: 'REFERENCE IMAGES: These images show the style you need to match. Analyze them and create adjustments that recreate this look.'
                    },
                    ...imageContents
                ]
            });
        }

        // No target image - create a preset based on the reference image style
        if (baseImageBase64) {
            messages.push({
                role: 'user',
                content: [
                    {
                type: 'text',
                        text: 'Create a preset based on the reference image style that can be applied to any similar image.'
                    }
                ]
            });
        }

        // Add hint/prompt
        if (hint) {
            messages.push({
                role: 'user',
                content: `STYLE DESCRIPTION: ${hint}`
            });
        }

        return messages;
    }

    private buildOpenAITools(options?: AIOptions): any[] {
        // Get enabled features from styleOptions (default to true if not set)
        const styleOpts = options?.styleOptions || {};
        const enableCurves = styleOpts.enableCurves !== false; // Default true
        const enableColorGrading = styleOpts.enableColorGrading !== false; // Default true
        const enableHSL = styleOpts.enableHSL !== false; // Default true
        const enableGrain = styleOpts.enableGrain !== false; // Default true
        const enableVignette = styleOpts.enableVignette !== false; // Default true
        const enablePointColor = styleOpts.enablePointColor !== false; // Default true

        // Build properties object conditionally
        const properties: any = {
            // Basic tone adjustments (always included)
            contrast: { type: 'number', description: 'Contrast adjustment (-100 to +100)' },
            highlights: { type: 'number', description: 'Highlights adjustment (-100 to +100)' },
            shadows: { type: 'number', description: 'Shadows adjustment (-100 to +100)' },
            whites: { type: 'number', description: 'Whites adjustment (-100 to +100)' },
            blacks: { type: 'number', description: 'Blacks adjustment (-100 to +100)' },
            vibrance: { type: 'number', description: 'Vibrance adjustment (-100 to +100)' },
            saturation: { type: 'number', description: 'Saturation adjustment (-100 to +100)' },
            temperature: { type: 'number', description: 'Temperature adjustment (-100 to +100)' },
            tint: { type: 'number', description: 'Tint adjustment (-100 to +100)' },
            camera_profile: { type: 'string', description: 'Camera profile name' },
        };

        // Add tone curves if enabled
        if (enableCurves) {
            properties.tone_curve = {
                type: 'array',
                description: 'RGB tone curve points. Array of {input, output} objects where values are 0-255. Use S-curves for film looks: lift shadows (0,0 to 30,20), compress highlights (200,200 to 255,240).',
                items: {
                    type: 'object',
                    properties: {
                        input: { type: 'number', description: 'Input value (0-255)' },
                        output: { type: 'number', description: 'Output value (0-255)' }
                    },
                    required: ['input', 'output']
                }
            };
            properties.tone_curve_red = {
                type: 'array',
                description: 'Red channel tone curve points. Array of {input, output} objects (0-255). Use for color-specific contrast adjustments.',
                items: {
                    type: 'object',
                    properties: {
                        input: { type: 'number', description: 'Input value (0-255)' },
                        output: { type: 'number', description: 'Output value (0-255)' }
                    },
                    required: ['input', 'output']
                }
            };
            properties.tone_curve_green = {
                type: 'array',
                description: 'Green channel tone curve points. Array of {input, output} objects (0-255).',
                items: {
                    type: 'object',
                    properties: {
                        input: { type: 'number', description: 'Input value (0-255)' },
                        output: { type: 'number', description: 'Output value (0-255)' }
                    },
                    required: ['input', 'output']
                }
            };
            properties.tone_curve_blue = {
                type: 'array',
                description: 'Blue channel tone curve points. Array of {input, output} objects (0-255).',
                items: {
                    type: 'object',
                    properties: {
                        input: { type: 'number', description: 'Input value (0-255)' },
                        output: { type: 'number', description: 'Output value (0-255)' }
                    },
                    required: ['input', 'output']
                }
            };
        }

        // Add color grading if enabled
        if (enableColorGrading) {
            properties.color_grade_shadow_hue = { type: 'number', description: 'Shadow color grading hue (0-360). Shift shadows warm (+20) or cool (-15) to match reference mood.' };
            properties.color_grade_shadow_sat = { type: 'number', description: 'Shadow color grading saturation (0-100). Typical: +5 to +15 for film looks.' };
            properties.color_grade_shadow_lum = { type: 'number', description: 'Shadow color grading luminance (-100 to +100). Lift shadows: +10 to +30.' };
            properties.color_grade_midtone_hue = { type: 'number', description: 'Midtone color grading hue (0-360). Adjust skin tones and overall color cast.' };
            properties.color_grade_midtone_sat = { type: 'number', description: 'Midtone color grading saturation (0-100). Typical: +5 to +20.' };
            properties.color_grade_midtone_lum = { type: 'number', description: 'Midtone color grading luminance (-100 to +100).' };
            properties.color_grade_highlight_hue = { type: 'number', description: 'Highlight color grading hue (0-360). Cool highlights (-15) or warm (+10) for atmosphere.' };
            properties.color_grade_highlight_sat = { type: 'number', description: 'Highlight color grading saturation (0-100). Typical: +5 to +15.' };
            properties.color_grade_highlight_lum = { type: 'number', description: 'Highlight color grading luminance (-100 to +100). Compress highlights: -10 to -30.' };
            properties.color_grade_global_hue = { type: 'number', description: 'Global color grading hue (0-360). Overall color shift.' };
            properties.color_grade_global_sat = { type: 'number', description: 'Global color grading saturation (0-100).' };
            properties.color_grade_global_lum = { type: 'number', description: 'Global color grading luminance (-100 to +100).' };
            properties.color_grade_blending = { type: 'number', description: 'Color grading blending (0-100). How much color grading affects the image.' };
            properties.color_grade_balance = { type: 'number', description: 'Color grading balance (-100 to +100). Balance between shadows and highlights.' };
        }

        // Add HSL adjustments if enabled
        if (enableHSL) {
            properties.hue_red = { type: 'number', description: 'Red hue adjustment (-100 to +100)' };
            properties.hue_orange = { type: 'number', description: 'Orange hue adjustment (-100 to +100)' };
            properties.hue_yellow = { type: 'number', description: 'Yellow hue adjustment (-100 to +100)' };
            properties.hue_green = { type: 'number', description: 'Green hue adjustment (-100 to +100)' };
            properties.hue_aqua = { type: 'number', description: 'Aqua hue adjustment (-100 to +100)' };
            properties.hue_blue = { type: 'number', description: 'Blue hue adjustment (-100 to +100)' };
            properties.hue_purple = { type: 'number', description: 'Purple hue adjustment (-100 to +100)' };
            properties.hue_magenta = { type: 'number', description: 'Magenta hue adjustment (-100 to +100)' };
            properties.sat_red = { type: 'number', description: 'Red saturation adjustment (-100 to +100)' };
            properties.sat_orange = { type: 'number', description: 'Orange saturation adjustment (-100 to +100)' };
            properties.sat_yellow = { type: 'number', description: 'Yellow saturation adjustment (-100 to +100)' };
            properties.sat_green = { type: 'number', description: 'Green saturation adjustment (-100 to +100)' };
            properties.sat_aqua = { type: 'number', description: 'Aqua saturation adjustment (-100 to +100)' };
            properties.sat_blue = { type: 'number', description: 'Blue saturation adjustment (-100 to +100)' };
            properties.sat_purple = { type: 'number', description: 'Purple saturation adjustment (-100 to +100)' };
            properties.sat_magenta = { type: 'number', description: 'Magenta saturation adjustment (-100 to +100)' };
            properties.lum_red = { type: 'number', description: 'Red luminance adjustment (-100 to +100)' };
            properties.lum_orange = { type: 'number', description: 'Orange luminance adjustment (-100 to +100)' };
            properties.lum_yellow = { type: 'number', description: 'Yellow luminance adjustment (-100 to +100)' };
            properties.lum_green = { type: 'number', description: 'Green luminance adjustment (-100 to +100)' };
            properties.lum_aqua = { type: 'number', description: 'Aqua luminance adjustment (-100 to +100)' };
            properties.lum_blue = { type: 'number', description: 'Blue luminance adjustment (-100 to +100)' };
            properties.lum_purple = { type: 'number', description: 'Purple luminance adjustment (-100 to +100)' };
            properties.lum_magenta = { type: 'number', description: 'Magenta luminance adjustment (-100 to +100)' };
        }

        // Add grain if enabled
        if (enableGrain) {
            properties.grain_amount = { type: 'number', description: 'Film grain amount (0-100)' };
            properties.grain_size = { type: 'number', description: 'Film grain size (0-100)' };
            properties.grain_frequency = { type: 'number', description: 'Film grain frequency (0-100)' };
        }

        // Add vignette if enabled
        if (enableVignette) {
            properties.vignette_amount = { type: 'number', description: 'Vignette amount (-100 to +100)' };
            properties.vignette_midpoint = { type: 'number', description: 'Vignette midpoint (0-100)' };
            properties.vignette_feather = { type: 'number', description: 'Vignette feather (0-100)' };
            properties.vignette_roundness = { type: 'number', description: 'Vignette roundness (-100 to +100)' };
        }

        // Add point color if enabled
        if (enablePointColor) {
            properties.point_colors = {
                type: 'array',
                description: 'Point color corrections. Array of color correction points.',
                items: { type: 'array', items: { type: 'number' } }
            };
        }

        // Build description based on enabled features
        const enabledFeatures: string[] = [];
        if (enableCurves) enabledFeatures.push('tone curves');
        if (enableColorGrading) enabledFeatures.push('color grading');
        if (enableHSL) enabledFeatures.push('HSL adjustments');
        if (enableGrain) enabledFeatures.push('film grain');
        if (enableVignette) enabledFeatures.push('vignette');
        if (enablePointColor) enabledFeatures.push('point color');
        
        const featuresDesc = enabledFeatures.length > 0 
            ? ` Enabled features: ${enabledFeatures.join(', ')}.`
            : '';

        const tools: any[] = [
            {
                type: 'function',
                function: {
                    name: 'analyze_color_palette',
                    description: 'MANDATORY: Analyze the color palette and dominant colors in the reference images. This is REQUIRED for all analysis.',
                    parameters: {
                        type: 'object',
                        properties: {
                            dominant_colors: {
                                type: 'array',
                                items: { type: 'string' },
                                description: 'Primary colors found in the reference images'
                            },
                            color_temperature: {
                                type: 'string',
                                enum: ['warm', 'cool', 'neutral'],
                                description: 'Overall color temperature'
                            },
                            color_saturation: {
                                type: 'string',
                                enum: ['muted', 'moderate', 'vibrant', 'oversaturated'],
                                description: 'Overall saturation level'
                            },
                            color_contrast: {
                                type: 'string',
                                enum: ['low', 'medium', 'high'],
                                description: 'Color contrast level'
                            },
                            color_relationships: {
                                type: 'string',
                                description: 'How colors relate to each other and create harmony'
                            },
                            style_notes: {
                                type: 'string',
                                description: 'Key observations about the color style'
                            }
                        },
                        required: ['dominant_colors', 'color_temperature', 'color_saturation', 'color_contrast', 'color_relationships', 'style_notes']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'generate_global_adjustments',
                    description: `MANDATORY: Generate global Lightroom/Camera Raw adjustments for the entire image. This is REQUIRED for all analysis.${featuresDesc} Use the enabled features to create impactful style matching.`,
                    parameters: {
                        type: 'object',
                        properties: properties,
                        required: ['contrast', 'highlights', 'shadows', 'whites', 'blacks', 'vibrance', 'saturation', 'temperature', 'tint', 'camera_profile']
                    }
                }
            },
            {
                type: 'function',
                function: {
                    name: 'name_and_describe',
                    description: 'MANDATORY: Generate a preset name and description for the recipe. This is REQUIRED for all analysis.',
                    parameters: {
                        type: 'object',
                        properties: {
                            preset_name: {
                                type: 'string',
                                description: 'Short, friendly preset name in Title Case (2-4 words)'
                            },
                            description: {
                                type: 'string',
                                description: '1-2 sentence description of the recipe style and mood'
                            },
                            confidence: {
                                type: 'number',
                                description: 'Confidence level (0.0 to 1.0) in the accuracy of the style match and adjustments'
                            }
                        },
                        required: ['preset_name', 'description', 'confidence']
                    }
                }
            }
        ];

        // Add masks tool if enabled (check both aiFunctions.masks and styleOptions.includeMasks)
        // Default is false (masks disabled)
        const includeMasks = options?.aiFunctions?.masks !== false && 
                            (options?.styleOptions?.includeMasks === true);
        if (includeMasks) {
            tools.push({
                type: 'function',
                function: {
                    name: 'generate_masks',
                    description: 'Generate local adjustment masks for targeted editing of specific areas. Use this to create precise local adjustments for faces, skies, subjects, or backgrounds.',
                    parameters: {
                        type: 'object',
                        properties: {
                            masks: {
                                type: 'array',
                                items: {
                                    type: 'object',
                                    properties: {
                                        type: { type: 'string', description: 'Mask type (face, sky, subject, background)' },
                                        name: { type: 'string', description: 'Mask name' },
                                        adjustments: {
                                            type: 'object',
                                            properties: {
                                                contrast: { type: 'number' },
                                                highlights: { type: 'number' },
                                                shadows: { type: 'number' },
                                                vibrance: { type: 'number' },
                                                saturation: { type: 'number' }
                                            }
                                        }
                                    }
                                },
                                maxItems: 3,
                                description: 'Array of masks to apply (max 3 masks)'
                            },
                            mask_strategy: {
                                type: 'string',
                                description: 'Strategy for mask placement and selection'
                            },
                            mask_notes: {
                                type: 'string',
                                description: 'Notes about why these masks were chosen'
                            }
                        },
                        required: ['masks', 'mask_strategy', 'mask_notes']
                    }
                }
            });
        }

        return tools;
    }


    private getDefaultAdjustments(): AIColorAdjustments {
        return {
            preset_name: 'Custom Recipe',
            description: 'A custom color grading recipe',
            camera_profile: 'Adobe Color',
            contrast: 0,
            highlights: 0,
            shadows: 0,
            whites: 0,
            blacks: 0,
            vibrance: 0,
            saturation: 0
        };
    }



    private ensureAdjustmentMetadata(adjustments: AIColorAdjustments | null): AIColorAdjustments {
        const ensured = adjustments ? { ...adjustments } : { ...this.createDefaultAdjustments() };

        if (!ensured.description || ensured.description.trim().length === 0) {
            ensured.description = 'A professional color grading recipe with carefully balanced tones and contrast.';
        }

        if (!ensured.preset_name || ensured.preset_name.trim().length === 0) {
            ensured.preset_name = 'Custom Recipe';
        }

        // Ensure confidence is always set
        if (ensured.confidence === undefined || ensured.confidence === null) {
            ensured.confidence = 0.5; // Default confidence when not provided by AI
        }

        const normalizedProfile = this.normalizeCameraProfileName(ensured.camera_profile) || this.autoSelectProfileFromResult(ensured);
        ensured.camera_profile = normalizedProfile;

        return ensured;
    }

    private getSystemPrompt(options: AIOptions): string {
        // Default is false (masks disabled)
        const includeMasks = options?.aiFunctions?.masks !== false && 
                            (options?.styleOptions?.includeMasks === true);
        
        // Get enabled features from styleOptions (default to true if not set)
        const styleOpts = options?.styleOptions || {};
        const enableCurves = styleOpts.enableCurves !== false;
        const enableColorGrading = styleOpts.enableColorGrading !== false;
        const enableHSL = styleOpts.enableHSL !== false;
        const enableGrain = styleOpts.enableGrain !== false;
        const enableVignette = styleOpts.enableVignette !== false;
        const enablePointColor = styleOpts.enablePointColor !== false;

        const base = getCoreSystemPrompt({
            includeMaskTypes: includeMasks,
            includeTechniques: true,
            includeRequirements: true
        });
        const maskInstruction = includeMasks 
            ? '' 
            : '\n\nIMPORTANT: DO NOT generate any masks or local adjustments. Only create global adjustments.';
        
        // Build feature-specific instructions
        const featureInstructions: string[] = [];
        
        if (enableCurves) {
            featureInstructions.push('- **TONE CURVES ENABLED**: You MUST include tone_curve in generate_global_adjustments for ALL presets (this is critical for style matching). Analyze the reference image\'s contrast curve and create matching tone curves (S-curves for film looks, lifted shadows, compressed highlights). Example: [{input:0,output:0}, {input:30,output:20}, {input:200,output:200}, {input:255,output:240}]');
        } else {
            featureInstructions.push('- **TONE CURVES DISABLED**: Do NOT include tone_curve, tone_curve_red, tone_curve_green, or tone_curve_blue in your adjustments.');
        }
        
        if (enableColorGrading) {
            featureInstructions.push('- **COLOR GRADING ENABLED**: You MUST include color_grade_shadow_hue, color_grade_shadow_sat, color_grade_midtone_hue, color_grade_highlight_hue, etc. to match color temperature and mood. Color grading is a PRIMARY tool for matching reference styles. Example: warm shadows (hue: +20, sat: +10), cool highlights (hue: -15, sat: +5)');
        } else {
            featureInstructions.push('- **COLOR GRADING DISABLED**: Do NOT include any color_grade_* parameters in your adjustments.');
        }
        
        if (enableHSL) {
            featureInstructions.push('- **HSL ADJUSTMENTS ENABLED**: Use hue_*, sat_*, and lum_* parameters to fine-tune specific colors and match the reference style.');
        } else {
            featureInstructions.push('- **HSL ADJUSTMENTS DISABLED**: Do NOT include any hue_*, sat_*, or lum_* parameters in your adjustments.');
        }
        
        if (enableGrain) {
            featureInstructions.push('- **FILM GRAIN ENABLED**: Include grain_amount, grain_size, and grain_frequency to match film texture characteristics.');
        } else {
            featureInstructions.push('- **FILM GRAIN DISABLED**: Do NOT include grain_amount, grain_size, or grain_frequency in your adjustments.');
        }
        
        if (enableVignette) {
            featureInstructions.push('- **VIGNETTE ENABLED**: Include vignette_amount, vignette_midpoint, vignette_feather, and vignette_roundness if the reference style shows vignetting.');
        } else {
            featureInstructions.push('- **VIGNETTE DISABLED**: Do NOT include any vignette_* parameters in your adjustments.');
        }
        
        if (enablePointColor) {
            featureInstructions.push('- **POINT COLOR ENABLED**: Use point_colors for targeted color corrections if needed.');
        } else {
            featureInstructions.push('- **POINT COLOR DISABLED**: Do NOT include point_colors in your adjustments.');
        }

        return `${base}${maskInstruction}

CRITICAL REFERENCE IMAGE REQUIREMENTS:
- When reference images are provided, you MUST analyze them thoroughly
- You always need to create a profile for the preset. Never return JSON!
- Create adjustments that precisely match the reference style
- Use the analyze_color_palette tool to understand the color characteristics
- Use the generate_global_adjustments tool to create matching adjustments
- Use the name_and_describe tool to create an appropriate preset name and confidence level

ENABLED MODIFICATIONS:
${featureInstructions.join('\n')}

IMPORTANT: Only use the features that are enabled above. Do NOT include parameters for disabled features.

CONFIDENCE CALCULATION:
- Assess how well you can match the reference style (0.0 = poor match, 1.0 = perfect match)
- Consider: clarity of reference images, distinctiveness of style, complexity of adjustments needed
- Higher confidence (0.7-1.0): Clear reference images with distinctive, achievable styles
- Medium confidence (0.4-0.7): Good reference images but complex or subtle style differences
- Lower confidence (0.1-0.4): Unclear references, very subtle styles, or complex multi-style combinations
- Always provide a confidence value between 0.0 and 1.0

CRITICAL TOOL USAGE REQUIREMENTS:
- You MUST use the available tools to complete your task
- Always call the required tools to generate a complete preset
- Do not provide text-only responses - use the tools instead`;
    }



    private parseResultFromText(text: string): AIColorAdjustments | null {
        // Try to extract structured data from the text
        try {
            // Look for JSON-like structures in the text
            const jsonMatches = text.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g);
            if (jsonMatches) {
                for (const match of jsonMatches) {
                    try {
                        const parsed = JSON.parse(match);
                        // Check if it looks like a valid AIColorAdjustments object
                        if (parsed && typeof parsed === 'object' && (parsed.preset_name || parsed.confidence !== undefined)) {
                            return parsed as AIColorAdjustments;
                        }
                    } catch {
                        // Continue to next match
                        continue;
                    }
                }
            }
        } catch (error) {
            console.warn('Could not parse result from text:', error);
        }
        return null;
    }

    // Normalize any free-form profile name to Adobe's canonical set
    private normalizeCameraProfileName(name?: string): string | undefined {
        if (!name) return undefined;
        const n = String(name).toLowerCase();
        if (/mono|black\s*&?\s*white|b\s*&\s*w/.test(n)) return 'Adobe Monochrome';
        if (/portrait|people|skin/.test(n)) return 'Adobe Portrait';
        if (/landscape|sky|mountain|nature/.test(n)) return 'Adobe Landscape';
        if (/color|standard|default|auto/.test(n)) return 'Adobe Color';
        return 'Adobe Color';
    }

    // Pick an Adobe profile using the adjustments and mask hints
    private autoSelectProfileFromResult(adjustments: AIColorAdjustments): string {
        const isBW =
            !!adjustments.monochrome ||
            adjustments.treatment === 'black_and_white' ||
            (typeof adjustments.saturation === 'number' && adjustments.saturation <= -100);
        if (isBW) return 'Adobe Monochrome';

        const masks = (adjustments as any).masks || [];
        let faceCount = 0;
        let landscapeLike = 0;
        let hasSky = false;
        for (const m of masks) {
            let t: any = m?.type;
            if (typeof t === 'string') t = normalizeMaskType(t);
            const cfg = typeof t === 'string' ? getMaskConfig(t) : undefined;
            const cat = cfg?.category;
            if (cat === 'face' || t === 'subject' || t === 'person') faceCount++;
            if (cat === 'landscape' || cat === 'background') landscapeLike++;
            if (t === 'sky') hasSky = true;
        }
        if (faceCount > 0) return 'Adobe Portrait';
        if (hasSky || landscapeLike > 0) return 'Adobe Landscape';
        return 'Adobe Color';
    }

    private createDefaultAdjustments(): AIColorAdjustments {
        return {
            preset_name: 'Custom Recipe',
            description: 'A balanced color grading recipe with natural tones and clean contrast.',
            confidence: 0.5,
            camera_profile: 'Adobe Color',
            contrast: 0,
            highlights: 0,
            shadows: 0,
            whites: 0,
            blacks: 0,
            vibrance: 0,
            saturation: 0
        };
    }


}
