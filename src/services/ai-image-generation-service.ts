import OpenAI from 'openai';

export interface RecipeImageGenerationOptions {
  recipeName?: string;
  prompt?: string;
  artistStyle?: { name: string; description?: string };
  filmStyle?: { name: string; description?: string };
  orientation?: 'portrait' | 'landscape' | 'street';
  colorAdjustments?: any; // Full color adjustments from recipe
}

export class AIImageGenerationService {
  private openai: OpenAI;

  constructor(apiKey: string) {
    this.openai = new OpenAI({
      apiKey: apiKey,
    });
  }

  async generateRecipeImage(options: RecipeImageGenerationOptions): Promise<{
    success: boolean;
    imageUrl?: string;
    error?: string;
  }> {
    try {
      // Build the prompt based on the recipe options
      const prompt = this.buildPrompt(options);
      
      // Generate image using OpenAI Images API
      const response = await this.openai.images.generate({
        model: "gpt-image-1",
        prompt: prompt,
        n: 1,
        size: "1024x1024",
        quality: "low"
      });

      console.log('OpenAI Response:', JSON.stringify(response, null, 2));

      if (!response.data || response.data.length === 0) {
        return {
          success: false,
          error: 'No image generated by GPT-Image-1'
        };
      }

      const imageData = response.data[0];
      console.log('Image data:', JSON.stringify(imageData, null, 2));

      // Check if we have a URL or base64 data
      if (imageData.url) {
        // Download the image and convert to base64 data URL
        const imageResponse = await fetch(imageData.url);
        const imageBuffer = await imageResponse.arrayBuffer();
        const imageBase64 = Buffer.from(imageBuffer).toString('base64');
        const dataUrl = `data:image/png;base64,${imageBase64}`;
        
        return {
          success: true,
          imageUrl: dataUrl
        };
      } else if (imageData.b64_json) {
        // Use base64 data directly
        const dataUrl = `data:image/png;base64,${imageData.b64_json}`;
        
        return {
          success: true,
          imageUrl: dataUrl
        };
      } else {
        return {
          success: false,
          error: 'No valid image data found in response'
        };
      }
    } catch (error) {
      console.error('AI Image Generation Error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      };
    }
  }

  private buildPrompt(options: RecipeImageGenerationOptions): string {
    let prompt = '';

    // Add recipe name context
    if (options.recipeName) {
      prompt += `Film recipe style: ${options.recipeName}. `;
    }

    // Add custom prompt
    if (options.prompt) {
      prompt += options.prompt;
    } else {
      // Build default prompt based on style options
      if (options.artistStyle) {
        prompt += `In the style of ${options.artistStyle.name}`;
        if (options.artistStyle.description) {
          prompt += ` (${options.artistStyle.description})`;
        }
        prompt += '. ';
      }

      if (options.filmStyle) {
        prompt += `${options.filmStyle.name} film aesthetic`;
        if (options.filmStyle.description) {
          prompt += ` (${options.filmStyle.description})`;
        }
        prompt += '. ';
      }

      // Add orientation
      if (options.orientation) {
        prompt += `${options.orientation} composition. `;
      }

      // Add color context from adjustments
      if (options.colorAdjustments) {
        const colorContext = this.getColorContext(options.colorAdjustments);
        if (colorContext) {
          prompt += colorContext;
        }
      }
    }

    // Add quality and technical specifications
    prompt += 'High quality, professional photography, detailed, cinematic lighting.';

    return prompt;
  }

  private getColorContext(adjustments: any): string {
    const context: string[] = [];

    // Analyze exposure
    if (adjustments.exposure && adjustments.exposure !== 0) {
      if (adjustments.exposure > 0) {
        context.push('bright, well-exposed');
      } else {
        context.push('moody, underexposed');
      }
    }

    // Analyze contrast
    if (adjustments.contrast && adjustments.contrast !== 0) {
      if (adjustments.contrast > 0) {
        context.push('high contrast');
      } else {
        context.push('low contrast, soft');
      }
    }

    // Analyze saturation
    if (adjustments.saturation && adjustments.saturation !== 0) {
      if (adjustments.saturation > 0) {
        context.push('vibrant colors');
      } else {
        context.push('desaturated, muted colors');
      }
    }

    // Analyze vibrance
    if (adjustments.vibrance && adjustments.vibrance !== 0) {
      if (adjustments.vibrance > 0) {
        context.push('enhanced color vibrancy');
      } else {
        context.push('reduced color intensity');
      }
    }

    // Analyze highlights and shadows
    if (adjustments.highlights && adjustments.highlights < 0) {
      context.push('preserved highlights');
    }
    if (adjustments.shadows && adjustments.shadows > 0) {
      context.push('lifted shadows');
    }

    return context.length > 0 ? context.join(', ') + '. ' : '';
  }
}
